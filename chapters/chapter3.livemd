# Learn4Elixir - Cap√≠tulo 3

## Estruturas de Controle

Neste capitulo iremos nos aprofundar em Estruturas de Controle.

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter3.livemd)

## If e Unless

'if' e 'unless' s√£o estruturas de controle que voc√™ pode usar no Elixir. Eles funcionam de maneira semelhante ao condicional 'if' e 'unless' em outras linguagens de programa√ß√£o. Aqui est√° como voc√™ pode us√°-los:

## If

A estrutura 'if' √© usada para executar um bloco de c√≥digo se uma condi√ß√£o for avaliada como verdadeira ou algum valor 'truthy'. Se a condi√ß√£o for avaliada como falsa ou algum valor 'falsy', o bloco de c√≥digo n√£o ser√° executado.

<!-- livebook:{"force_markdown":true} -->

```elixir
if condition do
  # C√≥digo a ser executado se a condi√ß√£o for verdadeira
end
```

Exemplo:

```elixir
age = 25

if age >= 18 do
  "Voc√™ √© maior de idade."
end
```

```elixir
age = 25

if age do
  "Voc√™ √© maior de idade."
end
```

```elixir
condicao = false

if condicao do
  "Voc√™ √© maior de idade."
end
```

```elixir
condicao = nil

if condicao do
  "Voc√™ √© maior de idade."
end
```

Observe que, se a condi√ß√£o for 'false' ou 'nil', o comando retorna 'nil', na aus√™ncia de uma cl√°usula 'else' (que veremos depois).

## Unless

A estrutura 'unless' √© mais ou menos o oposto do if. Ela √© usada para executar um bloco de c√≥digo se a condi√ß√£o for avaliada como falsa ou 'falsy'. Se a condi√ß√£o for avaliada como verdadeira ou 'truthy', 'nil' ser√° retornado.

<!-- livebook:{"force_markdown":true} -->

```elixir
unless condition do
  # C√≥digo a ser executado se a condi√ß√£o for falsa
end
```

Exemplo:

```elixir
raining = false

unless raining do
  "N√£o est√° chovendo."
end
```

```elixir
raining = nil

unless raining do
  "N√£o est√° chovendo."
end
```

```elixir
raining = true

unless raining do
  "N√£o est√° chovendo."
end
```

```elixir
raining = :oi

unless raining do
  "N√£o est√° chovendo."
end
```

Voc√™ tamb√©m pode usar 'else' com 'if' e 'unless' para executar um bloco de c√≥digo alternativo quando a condi√ß√£o n√£o for atendida.

<!-- livebook:{"force_markdown":true} -->

```elixir
if condition do
  # C√≥digo a ser executado se a condi√ß√£o for verdadeira
else
  # C√≥digo a ser executado se a condi√ß√£o for falsa
end
```

Exemplo:

```elixir
temperature = 28

if temperature > 30 do
  "Est√° quente l√° fora."
else
  "N√£o est√° t√£o quente l√° fora."
end
```

```elixir
temperature = 35

if temperature > 30 do
  "Est√° quente l√° fora."
else
  "N√£o est√° t√£o quente l√° fora."
end
```

A mesma l√≥gica se aplica ao 'unless' com 'else'.

```elixir
temperature = 28

unless temperature > 30 do
  "Est√° quente l√° fora."
else
  "N√£o est√° t√£o quente l√° fora."
end
```

```elixir
temperature = 35

unless temperature > 30 do
  "Est√° quente l√° fora."
else
  "N√£o est√° t√£o quente l√° fora."
end
```

## Cond

No Elixir, voc√™ pode usar a macro 'cond' para criar uma estrutura de controle condicional que permite avaliar m√∫ltiplas condi√ß√µes e executar c√≥digo com base na primeira condi√ß√£o verdadeira encontrada. A sintaxe b√°sica do cond √© a seguinte:

<!-- livebook:{"force_markdown":true} -->

```elixir
cond do
  condition1 ->
    # C√≥digo a ser executado se condition1 for verdadeira

  condition2 ->
    # C√≥digo a ser executado se condition2 for verdadeira

  condition3 ->
    # C√≥digo a ser executado se condition3 for verdadeira

  true ->
    # C√≥digo a ser executado se nenhuma das condi√ß√µes anteriores for verdadeira
end
```

Aqui est√£o alguns pontos-chave a serem observados sobre o cond no Livebook:

O cond avaliar√° as condi√ß√µes na ordem em que s√£o declaradas e executar√° o c√≥digo associado √† primeira condi√ß√£o verdadeira encontrada. Se nenhuma das condi√ß√µes for verdadeira, o bloco de c√≥digo associado a true ser√° executado, se presente.

As condi√ß√µes s√£o seguidas por uma seta (->) e, em seguida, o c√≥digo a ser executado se a condi√ß√£o for verdadeira.

A √∫ltima cl√°usula com true √© opcional, mas √© uma boa pr√°tica inclu√≠-la para tratar casos em que nenhuma das condi√ß√µes anteriores √© verdadeira.

Aqui est√° um exemplo de uso do cond no Livebook:

```elixir
x = :a

cond do
  is_number(x) and x == 0 ->
    "x √© igual a 0"

  is_number(x) and x > 0 ->
    "x √© maior que 0"

  is_number(x) and x < 0 ->
    "x √© menor que 0"

  true ->
    "Nenhuma das condi√ß√µes anteriores foi atendida"
end
```

Neste exemplo, o c√≥digo verificar√° a condi√ß√£o x == 0 primeiro, que n√£o √© verdadeira, e, em seguida, verificar√° x > 0, que √© verdadeira, portanto, imprimir√° "x √© maior que 0". Como a √∫ltima cl√°usula com true est√° presente, ela n√£o ser√° executada neste caso.

<!-- livebook:{"break_markdown":true} -->

Mude o valor de 'x' no c√≥digo acima para 0 e -1 e reavalie, para ver o que acontece. Depois, mude 'x' para o √°tomo ':a' e reavalie.

## Sigils

Elixir fornece uma sintaxe alternativa para representar e trabalhar com literais. Um sigil (s√≠mbolo especial) vai come√ßar com um til ~ seguido por um caractere. O n√∫cleo do Elixir fornece-nos alguns sigils, no entanto, √© poss√≠vel criar o nosso pr√≥prio sigil quando precisamos estender a linguagem.

Uma lista de sigils dispon√≠veis incluem:

* ~C Gera uma lista de caracteres sem escape ou interpola√ß√£o
* ~c Gera uma lista de caracteres com escape e interpola√ß√£o
* ~R Gera uma express√£o regular sem escape ou interpola√ß√£o
* ~r Gera uma express√£o regular com escape e interpola√ß√£o
* ~S Gera strings sem escape ou interpola√ß√£o
* ~s Gera string com escape e interpola√ß√£o
* ~W Gera uma lista sem escape ou interpola√ß√£o
* ~w Gera uma lista com escape e interpola√ß√£o
* ~N Gera uma NaiveDateTime struct

Uma lista de delimitadores inclui:

* <...> Um par de brackets
* {...} Um par de chaves
* [...] Um par de colchetes
* (...) Um par de par√™nteses
* |...| Um par de pipes
* /.../ Um par de barras
* "..." Um par de aspas duplas
* '...' Um par de aspas simples

Aqui est√£o alguns exemplos de como usar sigils no Livebook:

## Sigil de String (~s)

Voc√™ pode usar o sigil ~s para criar strings. O texto deve ser colocado entre colchetes {}. Por exemplo:

```elixir
~s{Isso √© uma string criada com sigil}
```

Isso retornar√° "Isso √© uma string criada com sigil" na sa√≠da.

## Sigil de Regex (~r)

O sigil ~r permite criar express√µes regulares. Voc√™ pode delimitar a express√£o regular com barras /. Por exemplo:

```elixir
# Esta express√£o regular corresponde a um ou mais d√≠gitos.
regex = ~r/\d+/
texto = "123 ABC  45 CDE"
Regex.scan(regex, texto)
```

Isso ir√°  retornar uma lista de resultados. Cada resultado ser√° uma lista contendo uma string que satisfaz √† express√£o regular, que espera caraceteres num√©ricos.

## Sigil de Caracter (~c)

O sigil ~c permite criar caracteres. Voc√™ pode especificar um √∫nico caractere entre aspas simples '. Por exemplo:

```elixir
~c'A'
```

Isso retornar√° "A".

## Sigil de Listas (~w):

O sigil ~w permite criar listas de palavra (strings) a partir de √°tomos, expressos sem os ":" iniciais. Voc√™ pode delimitar as palavras com espa√ßos. Por exemplo:

```elixir
~w(apple banana cherry)
```

## Compreens√µes

No Elixir, voc√™ pode usar compreens√µes para criar listas ou outras estruturas de dados de maneira concisa e expressiva. Compreens√µes s√£o uma caracter√≠stica poderosa em Elixir e podem ajudar a simplificar a cria√ß√£o e transforma√ß√£o de cole√ß√µes de dados. Aqui est√£o algumas formas de usar compreens√µes:

## Compreens√µes de Lista

Voc√™ pode criar listas usando compreens√µes de lista. A estrutura b√°sica de uma compreens√£o de lista √© a seguinte:

<!-- livebook:{"force_markdown":true} -->

```elixir
for pattern <- enumerable, filter, do: expression
```

* 'pattern' √© uma vari√°vel que representa cada elemento da cole√ß√£o 'enumerable'.
* 'enumerable' √© uma cole√ß√£o de dados, como uma lista, um mapa ou um conjunto.
* 'filter' (opcional) √© uma condi√ß√£o que filtra os elementos da cole√ß√£o.
* 'expression' √© o valor que ser√° inclu√≠do na lista resultante.

Exemplos:

```elixir
lista = [1, 2, 3, 4, 5]
for x <- lista, do: x * x
```

```elixir
lista = [1, 2, 3, 4, 5]
for x <- lista, x < 4, do: x * x
```

```elixir
lista = [10, 2, 30, 4, 50]
for x <- lista, x > 3, x < 40, do: "#{x + 3}"
```

## Compreens√µes de Mapa

Voc√™ tamb√©m pode usar compreens√µes para criar mapas. A estrutura b√°sica de uma compreens√£o de mapa √© semelhante √† compreens√£o de lista:

<!-- livebook:{"force_markdown":true} -->

```elixir
for {key, value} <- enumerable, filter, do: {key, expression}
```

<!-- livebook:{"break_markdown":true} -->

Exemplo:

```elixir
mapa = %{"a" => 1, "b" => 2, "c" => 3}
triplica_valores = for {chave, valor} <- mapa, do: {chave, valor * 3}
```

## Compreens√µes Aninhadas

Voc√™ pode aninhar compreens√µes dentro de outras compreens√µes para trabalhar com cole√ß√µes mais complexas. Por exemplo, voc√™ pode criar uma lista de listas usando uma compreens√£o aninhada.

Exemplo:

```elixir
matriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
elementos_pares = for linha <- matriz, valor <- linha, rem(valor, 2) == 0, do: valor
```

## Guard Clauses

Voc√™ pode usar guard clauses nas compreens√µes para aplicar condi√ß√µes adicionais aos elementos.

Exemplo:

```elixir
lista = [1, 2, 3, 4, 5, 6]
pares_maiores_que_tres = for x <- lista, rem(x, 2) == 0, x > 3, do: x
```

## Exerc√≠cios

### Exerc√≠cio 1

Voc√™ √© um desenvolvedor Elixir que trabalha para uma empresa de jogos chamada "ElixGames". A empresa est√° criando um jogo de aventura em que os jogadores exploram um mundo m√°gico cheio de criaturas misteriosas. Como parte do jogo, voc√™ precisa implementar uma fun√ß√£o que determina o resultado de um encontro aleat√≥rio com uma criatura.

Aqui est√£o as regras para determinar o resultado do encontro:

* Se o jogador estiver em um "Bosque Encantado", ele tem 90% de chance de encontrar uma criatura amig√°vel e 10% de chance de encontrar uma criatura hostil.
* Se o jogador estiver em uma "Caverna Escura", ele tem 60% de chance de encontrar uma criatura amig√°vel e 40% de chance de encontrar uma criatura hostil.
* Se o jogador estiver em uma "Torre Misteriosa", ele tem 30% de chance de encontrar uma criatura amig√°vel e 70% de chance de encontrar uma criatura hostil.

Sua tarefa √© implementar um m√≥dulo em Elixir chamado `ElixGames.Encontro` que forne√ßa a fun√ß√£o `determina_encontro/2`, que aceita o local onde o jogador est√° e um n√∫mero aleat√≥rio entre 1 e 100 (representando a probabilidade) como argumentos e retorna o resultado do encontro com a criatura com base nas regras acima.

Para completar esta tarefa, voc√™ precisar√° usar estruturas condicionais, como `if`, `unless` e `cond`, para aplicar as regras corretamente e determinar se o jogador encontrar√° uma criatura amig√°vel ou hostil com base no local e na probabilidade gerada aleatoriamente. Certifique-se de que a API (o nome do m√≥dulo, da fun√ß√£o e suas assinaturas) seja respeitada, conforme especificado pela empresa "ElixGames".

```elixir
defmodule ElixGames.Encontro do
  def determina_encontro(localizacao, probabilidade)
      when probabilidade >= 0 and probabilidade <= 100 do
    cond do
      localizacao == "Bosque Encantado" ->
        if probabilidade <= 90 do
          "Amig√°vel üòÖ"
        else
          "Hostil üò°"
        end

      localizacao == "Caverna Escura" ->
        if probabilidade <= 60 do
          "Amig√°vel üòÖ"
        else
          "Hostil üò°"
        end

      localizacao == "Torre Misteriosa" ->
        if probabilidade <= 30 do
          "Amig√°vel üòÖ"
        else
          "Hostil üò°"
        end

      true ->
        "localiza√ß√£o desconhecida"
    end
  end
end
```

```elixir
ElixGames.Encontro.determina_encontro("Caverna Escura", 35)
```

### Exerc√≠cio 2

Voc√™ recebeu uma lista de informa√ß√µes de clientes em formato de string, mas elas est√£o desorganizadas e precisam ser formatadas corretamente. Cada informa√ß√£o de cliente √© separada por um ponto e v√≠rgula (;) e cont√©m os seguintes campos:

1. Nome do cliente (entre aspas duplas).
2. Idade do cliente (um n√∫mero).
3. Endere√ßo de e-mail do cliente.
4. N√∫mero de telefone do cliente.

A seguir est√° um exemplo de como as informa√ß√µes dos clientes est√£o atualmente:

<!-- livebook:{"force_markdown":true} -->

```elixir
"Fulano Tal",30,fulano@email.com,+5511995236587;"Ciclano Outro",25,ciclano@email.com,+5545996578452
```

> D√™ uma olhada como **sigils** funcionam. Principalmente `~s` e `~r`, leia tamb√©m sobre **express√µes regulares**.

**Tarefas:**

<!-- livebook:{"break_markdown":true} -->

1. Crie uma fun√ß√£o chamada `parsear_clientes/1` que receba a string de informa√ß√µes de clientes e a divida em uma lista de informa√ß√µes de clientes formatadas. Use o sigil `~s` para fazer isso.

```elixir
~r/\"(?<name>(.*?))\"/
|> Regex.named_captures("\"vitor\" estevam")
```

```elixir
parsear_clientes = fn informacao ->
  informacao
  |> String.split(";")
  |> Enum.map(fn x ->
    # v√°rios named capture para caso os valores viessem fora de ordem
    Regex.named_captures(~r/(?<phone>\+[\d]+)/, x)
    |> Map.merge(Regex.named_captures(~r/\"(?<nome>(.*?))\"/, x))
    |> Map.merge(Regex.named_captures(~r/(?<email>[\w-\.]+@([\w-]+\.)+[\w-]{2,4})/, x))
    |> Map.merge(Regex.named_captures(~r/(?<idade>\d{1,3})/, x))
  end)
end
```

```elixir
~s("Fulano Tal",30,fulano@email.com,+5511995236587;"Ciclano Outro",25,ciclano@email.com,+5545996578452)
|> parsear_clientes.()
```

1. Crie outra fun√ß√£o chamada `extrair_nomes/1` que receba a lista de informa√ß√µes de clientes e retorne uma lista com os nomes dos clientes.

```elixir
extrair_nomes = fn informacao ->
  informacao
  |> Enum.map(fn x -> Map.get(x, "nome") end)
end
```

```elixir
# Caso a entrada fosse o exemplo na descri√ß√£o deve imprimir ["Fulano Tal", "Ciclano Outro"]
~s("Fulano Tal",30,fulano@email.com,+5511995236587;"Ciclano Outro",25,ciclano@email.com,+5545996578452)
|> parsear_clientes.()
|> extrair_nomes.()
```

1. Crie uma terceira fun√ß√£o chamada `filtrar_clientes_por_idade/2` que receba a lista de informa√ß√µes de clientes e uma idade m√≠nima e retorne uma lista com as informa√ß√µes dos clientes que t√™m pelo menos a idade especificada.

```elixir
filtrar_clientes_por_idade = fn informacao, idade ->
  for x <- informacao, Map.get(x, "idade") |> String.to_integer() >= idade, do: x
end
```

```elixir
# Deveria imprimir [["Fulano Tal", 30, "fulano@email.com", "+5511995236587"]]
~s("Fulano Tal",30,fulano@email.com,+5511995236587;"Ciclano Outro",25,ciclano@email.com,+5545996578452)
|> parsear_clientes.()
|> filtrar_clientes_por_idade.(30)
```

### Exercicio 3

Voc√™ est√° trabalhando em uma empresa de e-commerce que vende produtos para pets. Voc√™ recebeu a tarefa de implementar uma fun√ß√£o que calcula o valor total de uma compra, aplicando poss√≠veis descontos de acordo com as regras de neg√≥cio. As regras s√£o as seguintes:

* Se a compra for acima de R$ 200,00, o cliente ganha 10% de desconto.
* Se a compra for acima de R$ 500,00, o cliente ganha 15% de desconto.
* Se a compra for acima de R$ 1000,00, o cliente ganha 20% de desconto.
* Se o cliente for um membro do clube de fidelidade, ele ganha mais 5% de desconto em qualquer compra.
* Se o cliente usar o cupom "UBL10", ele ganha mais 10% de desconto em qualquer compra.

Voc√™ deve implementar uma fun√ß√£o chamada `calcula_total` que recebe uma lista de produtos e um mapa com as informa√ß√µes do cliente (se ele √© membro do clube, se ele usou o cupom, etc) e retorna o valor total da compra com os descontos aplicados. Voc√™ pode usar fun√ß√µes de alta ordem para criar fun√ß√µes auxiliares que representam as regras de desconto e aplic√°-las na lista de produtos. Cada produto √© representado por um mapa com os campos `:nome`, `:preco` e `:quantidade`. Por exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
produtos = [
  %{nome: "Ra√ß√£o para gatos", preco: 50.00, quantidade: 2},
  %{nome: "Brinquedo para cachorro", preco: 30.00, quantidade: 1},
  %{nome: "Aqu√°rio", preco: 200.00, quantidade: 1}
]

cliente = %{
  membro_clube: true,
  cupom: "UBL10"
}

calcula_total(produtos, cliente) # deve retornar 243.00
```

```elixir
defmodule Ecommerce do
  def desconto_produtos() do
    fn
      valor when valor >= 1000 ->
        0.2

      valor when valor >= 500 ->
        0.15

      valor when valor >= 200 ->
        0.1

      _ ->
        0
    end
  end

  def desconto_usuario() do
    fn
      cliente when cliente.membro_clube ->
        0.05

      _ ->
        0
    end
  end

  def desconto_cupom() do
    fn
      cliente when cliente.cupom == "UBL10" ->
        0.1

      _ ->
        0
    end
  end

  def calcula_total(produtos, cliente) do
    valor =
      produtos
      |> Enum.map(fn x -> x.preco * x.quantidade end)
      |> Enum.reduce(fn x, acc -> acc + x end)

    descontos = [
      # 10%
      desconto_produtos().(valor),
      # 5%
      desconto_usuario().(cliente),
      # 10%
      desconto_cupom().(cliente)
    ]

    valor
    |> Kernel.-(
      descontos
      |> Enum.map(fn x -> valor * x end)
      |> Enum.sum()
    )
  end
end
```

```elixir
produtos = [
  %{nome: "Ra√ß√£o para gatos", preco: 50.00, quantidade: 2},
  %{nome: "Brinquedo para cachorro", preco: 30.00, quantidade: 1},
  %{nome: "Aqu√°rio", preco: 200.00, quantidade: 1}
]

cliente = %{
  membro_clube: true,
  cupom: "UBL10"
}

expected = 247.5
result = Ecommerce.calcula_total(produtos, cliente)

{result, result == expected}
```

```elixir
produtos = [
  %{nome: "Ra√ß√£o para gatos", preco: 40, quantidade: 1}
]

cliente = %{
  membro_clube: false,
  cupom: ""
}

expected = 40
result = Ecommerce.calcula_total(produtos, cliente)

{result, result == expected}
```

```elixir
produtos = [
  %{nome: "Ra√ß√£o para gatos", preco: 40, quantidade: 1}
]

cliente = %{
  membro_clube: false,
  cupom: "UBL10"
}

expected = 36
result = Ecommerce.calcula_total(produtos, cliente)

{result, result == expected}
```

```elixir
produtos = [
  %{nome: "Aqu√°rio", preco: 200.00, quantidade: 5}
]

cliente = %{
  membro_clube: false,
  cupom: ""
}

expected = 800
result = Ecommerce.calcula_total(produtos, cliente)

{result, result == expected}
```
