# Learn4Elixir - Cap√≠tulo 2

## Fun√ß√µes em Elixir

Neste cap√≠tulo abordaremos fun√ß√µes em Elixir.

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FUniversidade-Livre%2FLearn4Elixir%2Fblob%2Fmain%2Fchapters%2Fchapter2.livemd)

## Fun√ß√µes nomeadas e m√≥dulos

Uma fun√ß√£o recebe zero ou mais valores como entrada e retorna um valor como sa√≠da. As entradas e sa√≠das podem ser de todos os tipos de Elixir (inclusive dos que n√£o mostraremos aqui).

<!-- livebook:{"break_markdown":true} -->

Elixir j√° vem com v√°rias fun√ß√µes. Estas fun√ß√µes fazem parte de m√≥dulos. Por exemplo, o m√≥dulo ['String'](https://hexdocs.pm/elixir/1.15.0/String.html) cont√©m a fun√ß√£o 'upcase', com aridade 2 (portanto, nos referimos a ela como 'String.upcase/2'), que converte todos os caracteres em uma cadeia de caracteres para letras mai√∫sculas.

```elixir
String.upcase("n√£o grite, por favor!")
```

Voc√™ pode ter achado estranho a aplica√ß√£o de String.upcase/2 acima receber apenas um argumento. Isto acontece pois Elixir permite que sejam definidas fun√ß√µes com argumentos _default_. Neste caso, o segundo argumento √© o modo. Se voc√™ n√£o passar nada, √© o mesmo que chamar da seguinte forma:

```elixir
String.upcase("n√£o grite, por favor!", :default)
```

Mas eu posso escolher entre quatro valores: :default, :ascii, :greek, :turkic. Vamos testar dois deles e observar a diferen√ßa.

```elixir
# observe o "√£"
String.upcase("n√£o grite, por favor!", :ascii)
```

```elixir
# observe o I acentuado
String.upcase("n√£o grite, por favor!", :turkic)
```

## Definindo suas pr√≥prias fun√ß√µes nomeadas e seus m√≥dulos

Voc√™ pode definir seu pr√≥prio m√≥dulo usando 'defmodule'. E suas fun√ß√µes usando 'def'. Veja a sintaxe nos exemplos abaixo:

```elixir
defmodule Matematica do
  def soma(num1, num2) do
    num1 + num2
  end

  def subtracao(num1, num2) do
    num1 - num2
  end
end
```

Observe que o formato √©:

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule <NOME_DO_MODULO> do
  def <NOME_DA_FUNCAO>(<LISTA_DE_ARGUMENTOS>) do
    <CORPO_DA_FUNCAO>
  end
end
```

<!-- livebook:{"break_markdown":true} -->

Depois que voc√™ define o m√≥dulo e o avalia, voc√™ pode usar suas fun√ß√µes.

```elixir
Matematica.soma(30, 40)
```

```elixir
Matematica.subtracao(30, 56)
```

Vamos definir outro m√≥dulo:

```elixir
Enum.sum([1.0, 3, 4])
```

```elixir
Enum.count([1, 34, 56, 78, 1])
```

```elixir
defmodule Turma do
  def media(lista_notas) do
    Enum.sum(lista_notas) / Enum.count(lista_notas)
  end

  def aprovado?(nota) when nota >= 6 do
    true
  end

  def aprovado?(_), do: false
end
```

No exemplo acima, usamos duas fun√ß√µes do [m√≥dulo Enum](https://hexdocs.pm/elixir/1.15.0/Enum.html): uma para somar todos os valores de uma lista de notas (Enum.sum/1) e outra para contar quantas notas tem na lista (Enum.count/1). A partir disto, calculamos a m√©dia de todas as notas da turma.

<!-- livebook:{"break_markdown":true} -->

Em 'Turma.aprovado?/1' usamos a conven√ß√£o de terminar o nome da fun√ß√£o que sempre retorna um valor l√≥gico com '?'.

<!-- livebook:{"break_markdown":true} -->

Na linha 6 'def aprovado?(nota) when nota>=6 do', usamos uma guarda, que √© introduzida com 'when' logo ap√≥s a lista de par√¢metros. N√£o temos tempo aqui de entrar em todos os detalhes de [guardas](https://hexdocs.pm/elixir/patterns-and-guards.html#list-of-allowed-functions-and-operators). Neste caso, estamos dizendo que se a nota for maior ou igual 6, 'true' ser√° retornado. Caso contr√°rio (observe o casamento de padr√µes em a√ß√£o na linha 9 com o uso do '\_'), 'false' ser√° retornado.
Ainda na linha 9, observe que em vez de:

<!-- livebook:{"force_markdown":true} -->

```elixir
def <NOME_DA_FUNCAO> <GUARDA_OPCIONAL> do
  <RESULTADO>
end
```

podemos escrever

<!-- livebook:{"force_markdown":true} -->

```elixir
def <NOME_DA_FUNCAO> <GUARDA_OPCIONAL>, do: <RESULTADO>
```

<!-- livebook:{"break_markdown":true} -->

Podemos ter v√°rias cl√°usulas (ou seja, v√°rios 'def's) para uma mesma fun√ß√£o. A primeira que se aplicar, ou seja, cujo padr√£o casar ser√° usada.

```elixir
Turma.media([10, 4, 6, 7, 8])
```

```elixir
Turma.aprovado?(6)
```

```elixir
Turma.aprovado?(5)
```

```elixir
Turma.aprovado?(7)
```

## Fun√ß√µes sem nome (an√¥nimas)

Agora que voc√™ j√° sabe o que s√£o fun√ß√µes, vamos falar pra voc√™ de um tipo de fun√ß√£o que pode ser muito √∫til em alguns casos: as fun√ß√µes sem nome (tamb√©m chamadas de "fun√ß√µes an√¥nimas").

<!-- livebook:{"break_markdown":true} -->

Fun√ß√µes an√¥nimas s√£o fun√ß√µes que, como o pr√≥prio nome diz, n√£o t√™m um nome. Elas s√£o descritas apenas definindo qual sua entrada (se alguma) e os comandos que v√£o produzir sua sa√≠da.

<!-- livebook:{"break_markdown":true} -->

No exemplo abaixo, definimos uma fun√ß√£o que recebe um valor 'num' (que representa um n√∫mero) e retorna este n√∫mero adicionado de 1.

```elixir
fn num -> num + 1 end
```

Quando voc√™ avalia o c√≥digo acima, voc√™ percebe que Elixir te d√° algo como:

```
#Function<42.125776118/1 in :erl_eval.expr/6>
```

Este valor, por si s√≥, n√£o tem muita utilidade para n√≥s.

<!-- livebook:{"break_markdown":true} -->

Como ent√£o podemos aplicar a fun√ß√£o an√¥nima que acabamos de definir a um valor, como 2? Normalmente n√£o fazemos isso em Elixir, mas uma solu√ß√£o √© atribuir a fun√ß√£o a uma vari√°vel.

```elixir
f = fn num -> num + 1 end
```

E s√≥ depois chamar a fun√ß√£o:

```elixir
f.(2)
```

Perceberam que, para chamar a fun√ß√£o 'f', precisamos colocar um ponto antes dos par√™nteses? √â uma caracter√≠stica de Ellxir (que na pr√°tica n√£o √© um problema).

<!-- livebook:{"break_markdown":true} -->

Outra forma √© fazer a chamada diretamente (tamb√©m usando o ponto):

```elixir
(fn num -> num + 1 end).(2)
```

## Fun√ß√µes de ordem mais alta

O uso realmente interessante de fun√ß√µes an√¥nimas √© em fun√ß√µes de ordem mais alta (_higher-order functions_). Fun√ß√µes de ordem mais alta recebem uma ou mais fun√ß√µes como argumento, ou retornam uma fun√ß√£o.

## O m√≥dulo Enum

O [m√≥dulo Enum](https://elixirschool.com/pt/lessons/basics/enum) inclui v√°rias fun√ß√µes de ordem mais alta.

<!-- livebook:{"break_markdown":true} -->

Por exemplo, a fun√ß√£o 'Enum.map/2' recebe, no exemplo abaixo, como entrada uma lista '[10, 20, 3, 45]' e uma fun√ß√£o an√¥nima de aridade 1 que soma 12 ao valor que receber:

```elixir
Enum.map([10, 20, 3, 45], fn x -> x + 12 end)
```

A fun√ß√£o 'Enum.reduce/3' recebe como argumento uma lista, um valor inicial e uma fun√ß√£o de aridade 2. No exemplo abaixo, a lista √© '[1, 2,3]', o valor inicial √© 0 e a fun√ß√£o soma um elemento da lista ao acumulador, que passa a ter o valor desta soma. Deste modo, o resultado ser√° '0+1+2+3'.

```elixir
Enum.reduce([1, 2, 3], 0, fn elemento, acumulador -> elemento + acumulador end)
```

E como seria um exemplo de uma fun√ß√£o que retorna outra fun√ß√£o?
No m√≥dulo abaixo n√≥s definimos uma fun√ß√£o 'HOF.incrementador/1', que recebe como entrada um n√∫mero e retorna uma fun√ß√£o de aridade 1 que incrementa um outro valor a este n√∫mero.

```elixir
defmodule HOF do
  def incrementador(numero) do
    fn valor -> valor + numero end
  end
end
```

Ou seja, se eu chamar desta forma:

```elixir
HOF.incrementador(3)
```

Eu obtenho uma fun√ß√£o que incrementa 3 ao valor que receber. Portanto, se eu passar 5 a esta fun√ß√£o, o resultado ser√° 8.

```elixir
HOF.incrementador(3).(5)
```

√â √∫til? N√£o lembro de nenhuma utilidade deste tipo de fun√ß√£o em meu c√≥digo. Mas pode ser √∫til em bibliotecas bem espec√≠ficas.

## O operador Pipe

O operador pipe (representado pelos dois s√≠mbolos '|>') √© uma forma de chamar fun√ß√µes que permite que as chamadas sejam encadeadas de uma forma elegante e pr√°tica.

<!-- livebook:{"break_markdown":true} -->

Por exemplo, em vez de fazer:

```elixir
require Integer
Enum.all?(Enum.map([1, 2, 3, 4], fn x -> x * 2 end), &Integer.is_even/1)
```

Podemos escrever:

```elixir
require Integer

[1, 2, 3, 4]
|> Enum.map(fn x -> x * 2 end)
|> Enum.all?(&Integer.is_even/1)
```

Ou seja, o pipe envia o resultado de uma express√£o como o primeiro par√¢metro para a pr√≥xima chamada a fun√ß√£o.

## Fun√ß√µes privadas em M√≥dulos

Uma funcionalidade que pode ser √∫til √© a defini√ß√£o de fun√ß√µes privadas em m√≥dulos.

<!-- livebook:{"break_markdown":true} -->

N√≥s vimos anteriormente como definir uma fun√ß√£o em um m√≥dulo:

```elixir
defmodule Mat do
  def media(num1, num2) do
    (num1 + num2) / 2
  end
end
```

Vamos supor que eu queira ter uma fun√ß√£o auxiliar, uma fun√ß√£o que √© usada apenas pelas outras fun√ß√µes do m√≥dulo. Este √© o caso em que definimos uma fun√ß√£o previada e para isso, em vez de 'def', usamos 'defp'.

```elixir
defmodule Matem do
  def media(num1, num2) do
    (num1 + num2) / 2
  end

  def fatorial(num) when num > 0 do
    fatorial(num, 1)
  end

  def fatorial(_num) do
    :error
  end

  defp fatorial(0, fatorial_atual) do
    fatorial_atual
  end

  defp fatorial(num, fatorial_atual) when num > 0 do
    fatorial(num - 1, fatorial_atual * num)
  end
end
```

```elixir
Matem.fatorial(1000)
```

## Exerc√≠cios

### Exerc√≠cio 1

<!-- livebook:{"break_markdown":true} -->

Voc√™ lembra do exerc√≠cio em que voc√™ fez no primeiro livebook? Percebeu que nesse cap√≠tulo implementamos ela utilizando o m√≥dulo `Enum`?

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Turma do
  def media(lista_notas) do
    Enum.sum(lista_notas) / Enum.count(lista_notas)
  end

  def aprovado?(nota) when nota >= 6 do
    true
  end

  def aprovado?(_), do: false
end
```

Elixir tem diversos m√≥dulos que possuem fun√ß√µes que podem nos auxiliar a simplificar o desenvolvimento de nosso c√≥digo, como vimos acima no uso de `Enum` e no inicio desse livebook com `String`.

* Leia essas documenta√ß√µes de forma r√°pida por cima e busque nelas informa√ß√µes quando for resolver esse exerc√≠cio: [Enum](https://hexdocs.pm/elixir/1.12/Enum.html), [String](https://hexdocs.pm/elixir/1.12/String.html) e [Map](https://hexdocs.pm/elixir/1.12/Map.html).

E ent√£o resolva esses problemas:

<!-- livebook:{"break_markdown":true} -->

1. Retorne o tamanho da String "pneumoultramicroscopicossilicovulcanoconi√≥tico".

```elixir
String.length("pneumoultramicroscopicossilicovulcanoconi√≥tico")
```

1. Retorne uma Lista que possui os mesmos items da lista [:a, :b, :c] por√©m com os itens na ordem contr√°ria, ou seja [:c, :b, :a].

```elixir
Enum.reverse([:a, :b, :c])
```

1. Retorne um novo mapa que √© a uni√£o desses dois mapas:

```elixir
primeiro_mapa = %{:um => 1, :dois => 2}
segundo_mapa = %{:tres => 3, :quatro => 4}
```

```elixir
Enum.concat(primeiro_mapa, segundo_mapa)
```

1. Retorne uma lista de palavras da senten√ßa:

```elixir
# execute essa c√©lula de c√≥digo
sentenca = """
Como de h√°bito, Policarpo Quaresma, mais conhecido por Major Quaresma, bateu em casa √†s quatro e quinze da tarde. Havia mais de vinte anos que isso acontecia. Saindo do Arsenal de Guerra, onde era subsecret√°rio, bongava pelas confeitarias algumas frutas, comprava um queijo, √†s vezes, e sempre o p√£o da padaria francesa.
"""
```

```elixir
sentenca
|> String.split([" ", ","])
|> Enum.filter(fn x -> x != "" end)
```

1. Crie uma nova lista onde cada elemento corresponde a um elemento  da lista abaixo multiplicado por 2. Depois disso, some todos os elementos da nova lista.

```elixir
# execute essa c√©lula de c√≥digo
lista_de_numeros = [4, 8, 12, 16, 20, 24, 28, 32, 36]
```

```elixir
lista_de_numeros
|> Enum.map(fn x -> x * 2 end)
# or Enum.sum
|> Enum.reduce(fn x, y -> x + y end)
```

### Exerc√≠cio 2

<!-- livebook:{"break_markdown":true} -->

O departamento de Matem√°tica da Universidade T√©cnica Federal do Paran√° entrou em contato com voc√™. Eles querem usar Elixir para trabalhar com √Ålgebra Linear e para isso precisam que voc√™ implemente um m√≥dulo em Elixir para que eles possam usar para fazer opera√ß√µes com Matrizes que eles precisam. Para eles √© importante:

* Soma de Matrizes
* Subtra√ß√£o de Matrizes
* Multiplica√ß√£o de Matrizes
* Multiplica√ß√£o de Matriz por Escalar (chamado de Produto Escalar)
* Determinante da Matriz (para Matrizes at√© 3x3)

Para a soma, subtra√ß√£o e multiplica√ß√£o de matrizes, as
matrizes inseridas poder√£o ter quaisquer dimens√µes (verifique se a opera√ß√£o √© fact√≠vel antes de
execut√°-la).

Uma matriz √© representada por Listas dentro de Listas em Elixir.

<!-- livebook:{"force_markdown":true} -->

```elixir
matriz = [[0,0,1], [0,1,0], [1,0,0]]
```

Voc√™ pode utilizar qualquer recurso ou t√©cnica, incluindo implementar fun√ß√µes auxiliares, features que ainda n√£o vimos at√© aqui ou qualquer outra coisa que julgar necess√°rio. Por√©m, com o que viu at√© aqui deve ser o suficiente para que possa implementar essa solu√ß√£o.

Abaixo, temos um "esqueleto" da implementa√ß√£o. Os professores esperam que essa "API" (o nome do m√≥dulo, das fun√ß√µes e suas assinaturas) sejam respeitadas, pois n√£o v√£o investigar a implementa√ß√£o, mas esperam usar chamando-as com esses nomes e assinaturas.

```elixir
defmodule AlgebraLinear do
  defp mesmo_tamanho?(a, b) do
    length(a) == length(b)
  end

  def soma_matrizes(a, b) do
    if !mesmo_tamanho?(a, b) do
      raise "As matrizes possuem tamanhos diferentes"
    end

    Enum.zip(a, b)
    |> Enum.map(fn {x, y} ->
      Enum.zip(x, y)
      |> Enum.map(&Tuple.to_list(&1))
      |> Enum.map(&Enum.reduce(&1, fn x, y -> x + y end))
    end)
  end

  def subtrai_matrizes(a, b) do
    if !mesmo_tamanho?(a, b) do
      raise "As matrizes possuem tamanhos diferentes"
    end

    Enum.zip(a, b)
    |> Enum.map(fn {x, y} ->
      Enum.zip(x, y)
      |> Enum.map(&Tuple.to_list(&1))
      |> Enum.map(&Enum.reduce(&1, fn y, x -> x - y end))
    end)
  end

  defp podem_multiplicar?(a, b) do
    # quantidade de colunas da matriz A precisa ser igual a quantidade de linhas da matriz B

    inverte_matriz(a)
    |> length == length(b)
  end

  def multiplica_matrizes(matriz_a, matriz_b) do
    if !podem_multiplicar?(matriz_a, matriz_b) do
      raise "As matrizes n√£o podem ser multiplicadas"
    end

    matriz_a
    |> Enum.map(fn x ->
      # inverte a matriz B
      Enum.zip(matriz_b)
      |> Enum.map(fn y ->
        # multiplica cada valor
        Enum.zip_with(x, Tuple.to_list(y), fn a, b -> a * b end)
        # soma os valores
        |> Enum.reduce(fn v, acc -> acc + v end)
      end)
    end)
  end

  def escalar(matriz, escalar) do
    matriz
    |> Enum.map(&Enum.map(&1, fn x -> x * escalar end))
  end

  defp inverte_matriz(matriz) do
    matriz
    |> Enum.zip()
    |> Enum.map(&Tuple.to_list(&1))
  end

  defp prepara_determinante(matriz) do
    matriz
    # inverte a matriz
    |> inverte_matriz
    # copia as primeiras 2 colunas pro final
    |> then(&Enum.concat(&1, Enum.slice(&1, 0, 2)))
    # reinverte a matriz
    |> inverte_matriz
    |> Enum.with_index()
    # remove os primeiros elementos da linha de acordo com o index
    |> Enum.map(fn {x, y} -> Enum.drop(x, y) end)
    |> then(&Enum.map(&1, fn x -> Enum.slice(x, 0, length(&1)) end))
  end

  defp soma_colunas(matriz) do
    matriz
    |> inverte_matriz
    |> Enum.map(&Enum.reduce(&1, fn x, y -> x * y end))
    |> Enum.sum()
  end

  defp pode_calcular_determinante?(matriz) do
    # a matriz precisa ser quadrada
    length(matriz)
    |> then(&Enum.all?(matriz, fn x -> length(x) == &1 end))
  end

  def determinante(matriz) when length(matriz) == 3 do
    if !pode_calcular_determinante?(matriz) do
      raise "As matriz precisa ser quadrada para que a determinante possa ser calculada"
    end

    matriz
    # prepara a matriz para calcular as diagonais
    |> prepara_determinante
    # soma as colunas e prepara novamente a matriz
    |> then(&(soma_colunas(&1) - (prepara_determinante(&1) |> soma_colunas)))
  end

  def determinante(matriz) when length(matriz) == 2 do
    if !pode_calcular_determinante?(matriz) do
      raise "As matriz precisa ser quadrada para que a determinante possa ser calculada"
    end

    [a, b | _] = matriz

    Enum.zip_with(a, Enum.reverse(b), fn x, y -> x * y end)
    |> Enum.reduce(fn x, acc -> acc - x end)
  end

  def determinante(matriz) when length(matriz) == 1 do
    if !pode_calcular_determinante?(matriz) do
      raise "As matriz precisa ser quadrada para que a determinante possa ser calculada"
    end

    matriz
    |> Enum.at(0)
    |> Enum.at(0)
    |> Kernel.abs()
  end
end
```

```elixir
matrizA = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]
matrizB = [[10, 11, 12], [13, 14, 15], [16, 17, 18]]
matrizC = [[1, 2, 3], [2, 5, 6], [2, 5, 8]]
matrizD = [[2, 5], [7, 3]]
matrizE = [[-1]]
matrizF = [[2, 5], [7, 3, 6]]
```

```elixir
expected = 2
final = AlgebraLinear.determinante(matrizC)
{final == expected, final}
```

```elixir
expected = -29
final = AlgebraLinear.determinante(matrizD)
{final == expected, final}
```

```elixir
expected = 1
final = AlgebraLinear.determinante(matrizE)
{final == expected, final}
```

```elixir
expected = [[10, 12, 14], [16, 18, 20], [22, 24, 26]]
final = AlgebraLinear.soma_matrizes(matrizA, matrizB)
```

```elixir
expected = [[-10, -10, -10], [-10, -10, -10], [-10, -10, -10]]
final = AlgebraLinear.subtrai_matrizes(matrizA, matrizB)
{final == expected, final}
```

```elixir
expected = [[0, 2, 4], [6, 8, 10], [12, 14, 16]]
final = AlgebraLinear.escalar(matrizA, 2)
{final == expected, final}
```

```elixir
expected = [[45, 48, 51], [162, 174, 186], [279, 300, 321]]
final = AlgebraLinear.multiplica_matrizes(matrizA, matrizB)
{final == expected, final}
```

```elixir
# testando multiplica√ß√£o de matrizes com tamanhos diferentes
matrizA2 = [[10, 11], [13, 14]]
matrizB2 = [[0, 1, 2], [3, 4, 5]]
expected = [[33, 54, 75], [42, 69, 96]]
final = AlgebraLinear.multiplica_matrizes(matrizA2, matrizB2)
{final == expected, final}
```

```elixir
AlgebraLinear.soma_matrizes(matrizA, matrizD)
```

```elixir
AlgebraLinear.determinante(matrizF)
```

### Exerc√≠cio 3

Voc√™ √© um desenvolvedor web que trabalha em uma empresa que oferece servi√ßos de streaming de m√∫sica. Voc√™ est√° usando Elixir para criar uma API que permite aos usu√°rios pesquisar, ouvir e avaliar as m√∫sicas dispon√≠veis na plataforma. Voc√™ recebeu uma tarefa de implementar uma fun√ß√£o que recebe uma lista de m√∫sicas e retorna uma lista de recomenda√ß√µes baseadas nas prefer√™ncias do usu√°rio.

Uma m√∫sica √© representada por um mapa com as seguintes chaves:

* **:titulo** - uma string com o nome da m√∫sica
* **:artista** - uma string com o nome do artista
* **:genero** - uma string com o g√™nero musical
* **:duracao** - um inteiro com a dura√ß√£o da m√∫sica em segundos
* **:avaliacao** - um n√∫mero de 0 a 5 com a avalia√ß√£o m√©dia da m√∫sica pelos usu√°rios

<!-- livebook:{"force_markdown":true} -->

```elixir
musica = %{
            titulo: "Starway to Heaven",
            artista: "Led Zeppelin",
            genero: "Rock",
            duracao: 482,
            avaliacao: 4.9
          }
```

Uma prefer√™ncia do usu√°rio √© representada por um mapa com as seguintes chaves:

* **:genero** - uma string com o g√™nero musical preferido pelo usu√°rio
* **:duracao_min** - um inteiro com a dura√ß√£o m√≠nima das m√∫sicas que o usu√°rio gosta em segundos
* **:duracao_max** - um inteiro com a dura√ß√£o m√°xima das m√∫sicas que o usu√°rio gosta em segundos
* **:avaliacao_min** - um n√∫mero de 0 a 5 com a avalia√ß√£o m√≠nima das m√∫sicas que o usu√°rio quer ouvir

<!-- livebook:{"force_markdown":true} -->

```elixir
preferencia = %{
                 genero: "Rock",
                 duracao_min: 200,
                 duracao_max: 400,
                 avaliacao_min: 4.5
                }
```

A fun√ß√£o de recomenda√ß√£o deve receber uma lista de m√∫sicas e uma prefer√™ncia do usu√°rio e retornar uma lista de m√∫sicas que atendem aos crit√©rios da prefer√™ncia, ordenadas por avalia√ß√£o em ordem decrescente. Se houver mais de uma m√∫sica com a mesma avalia√ß√£o, a ordem deve ser alfab√©tica pelo t√≠tulo.

Voc√™ deve usar fun√ß√µes an√¥nimas e as fun√ß√µes map, filter e reduce para implementar essa fun√ß√£o. Voc√™ pode usar qualquer recurso ou t√©cnica que julgar necess√°rio, mas com o que viu at√© aqui deve ser o suficiente para que possa implementar essa solu√ß√£o.

```elixir
defmodule Recomendacao do
  def recomenda(musicas, preferencia) do
    musicas
    |> Enum.filter(fn x -> x.genero == preferencia.genero end)
    |> Enum.filter(fn x -> x.duracao >= preferencia.duracao_min end)
    |> Enum.filter(fn x -> x.duracao <= preferencia.duracao_max end)
    |> Enum.filter(fn x -> x.avaliacao >= preferencia.avaliacao_min end)
    # provavelmente tem outra forma de fazer sort por dois valores
    |> Enum.sort_by(&{&1.avaliacao}, :desc)
    |> Enum.chunk_by(&{&1.avaliacao})
    # üí£
    |> Enum.map(fn x -> Enum.sort_by(x, &{&1.titulo}) end)
    |> Enum.concat()
  end
end
```

atriz

```elixir
# Define uma lista de m√∫sicas
musicas = [
  %{titulo: "Hotel California", artista: "Eagles", genero: "Rock", duracao: 391, avaliacao: 4.7},
  %{
    titulo: "ARolling in the Deep",
    artista: "Adele",
    genero: "Pop",
    duracao: 228,
    avaliacao: 4.8
  },
  %{
    titulo: "CRolling in the Deep",
    artista: "Adele",
    genero: "Pop",
    duracao: 228,
    avaliacao: 5.0
  },
  %{
    titulo: "BRolling in the Deep",
    artista: "Adele",
    genero: "Pop",
    duracao: 228,
    avaliacao: 5.0
  },
  %{
    titulo: "ARolling in the Deep",
    artista: "Adele",
    genero: "Pop",
    duracao: 228,
    avaliacao: 5.0
  },
  %{titulo: "Rolling in the Deep", artista: "Adele", genero: "Pop", duracao: 228, avaliacao: 4.8},
  %{titulo: "Rolling in the Deep", artista: "Adele", genero: "Pop", duracao: 228, avaliacao: 4.7},
  %{titulo: "Rolling in the Deep", artista: "Adele", genero: "Pop", duracao: 228, avaliacao: 4.5},
  %{titulo: "Bohemian Rhapsody", artista: "Queen", genero: "Rock", duracao: 355, avaliacao: 4.9},
  %{
    titulo: "Billie Jean",
    artista: "Michael Jackson",
    genero: "Pop",
    duracao: 292,
    avaliacao: 4.4
  },
  %{titulo: "Yesterday", artista: "The Beatles", genero: "Rock", duracao: 138, avaliacao: 4.6},
  %{titulo: "Shape of You", artista: "Ed Sheeran", genero: "Pop", duracao: 233, avaliacao: 4.1},
  %{
    titulo: "No Woman, No Cry",
    artista: "Bob Marley",
    genero: "Reggae",
    duracao: 245,
    avaliacao: 4.8
  },
  %{
    titulo: "Redemption Song",
    artista: "Bob Marley",
    genero: "Reggae",
    duracao: 179,
    avaliacao: 4.7
  }
]
```

```elixir
# Define uma prefer√™ncia do usu√°rio
preferencia = %{genero: "Pop", duracao_min: 200, duracao_max: 250, avaliacao_min: 4.5}
```

```elixir
# Chama a fun√ß√£o de recomenda√ß√£o com a lista de m√∫sicas e a prefer√™ncia do usu√°rio
Recomendacao.recomenda(musicas, preferencia)
```

### Exercicio 4

Voc√™ est√° participando de um emocionante concurso de escultura de c√≠rculos, onde artistas de todo o mundo exibem suas obras-primas circulares. Cada participante contribui com uma lista de raios de c√≠rculos usados em suas esculturas. O j√∫ri est√° ansioso para premiar as melhores esculturas, e voc√™ quer dar um toque de tecnologia √† sua apresenta√ß√£o.

Voc√™ decide criar um programa em Elixir para ajudar a analisar e apresentar os dados dos raios dos c√≠rculos de forma a impressionar os ju√≠zes. Seu programa ser√° respons√°vel por calcular v√°rias estat√≠sticas importantes dos raios, o que pode destacar a singularidade de sua escultura.

* Encontrar o raio m√≠nimo e m√°ximo para mostrar o qu√£o variados s√£o os tamanhos dos c√≠rculos em sua escultura.

* Calcular o di√¢metro correspondente aos raios m√≠nimo e m√°ximo para destacar a amplitude das dimens√µes dos c√≠rculos.

* Calcular a √°rea correspondente aos raios m√≠nimo e m√°ximo para ilustrar a diversidade de √°reas cobertas pelos c√≠rculos.

* Determinar a m√©dia dos raios para mostrar a propor√ß√£o m√©dia dos tamanhos.

* Saber quantos c√≠rculos diferentes voc√™ utilizou em sua escultura.

* Apresentar a lista de raios em ordem crescente e decrescente para enfatizar o equil√≠brio art√≠stico.

* Calcular a varia√ß√£o dos raios para demonstrar a diversidade na escolha de tamanhos.

* Destacar a mediana dos raios para mostrar uma dimens√£o central dos c√≠rculos usados.

```elixir
circulos = [2, 4, 3, 6, 20, 17, 5, 11, 9, 13, 2, 20]
```

Neste exerc√≠cio, a documenta√ß√£o oficial do m√≥dulo [Enum](https://hexdocs.pm/elixir/1.12/Enum.html) vai ser de grande ajuda. Sinta-se √† vontade para explorar os recursos e fun√ß√µes oferecidos por este m√≥dulo para realizar as opera√ß√µes desejadas em sua an√°lise de dados. Boa sorte em seu concurso de escultura de c√≠rculos!"

```elixir
defmodule CalculoEsculturas do
  def raio_minimo(circulos) do
    Enum.min(circulos)
  end

  def raio_maximo(circulos) do
    Enum.max(circulos)
  end

  def diametro_minimo(circulos) do
    raio_minimo(circulos) * 2
  end

  def diametro_maximo(circulos) do
    raio_maximo(circulos) * 2
  end

  def area_minima(circulos) do
    raio_minimo(circulos) * :math.pow(:math.pi(), 2)
  end

  def area_maxima(circulos) do
    raio_maximo(circulos) * :math.pow(:math.pi(), 2)
  end

  def media_raios(circulos) do
    Enum.sum(circulos) / length(circulos)
  end

  def numero_de_circulos(circulos) do
    length(circulos)
  end

  def ordena_raios(circulos) do
    Enum.sort(circulos)
  end

  def ordena_raios_descendente(circulos) do
    Enum.sort(circulos, :desc)
  end

  defp desvioPadrao(circulos) do
    circulos
    |> Enum.map(&Kernel.-(&1, media_raios(circulos)))
    |> Enum.map(&:math.pow(&1, 2))
    |> Enum.sum()
    |> Kernel./(numero_de_circulos(circulos))
    |> :math.sqrt()
  end

  def variacao_raios(circulos) do
    media = media_raios(circulos)
    desvio = desvioPadrao(circulos)
    desvio / media * 100
  end

  def mediana_raios(circulos) when rem(length(circulos), 2) != 0 do
    tamanho = length(circulos)

    ordena_raios(circulos)
    |> Enum.fetch!(trunc(tamanho / 2))
  end

  def mediana_raios(circulos) do
    tamanho = length(circulos)

    circulos = ordena_raios(circulos)

    a = Enum.fetch!(circulos, trunc(tamanho / 2 - 1))
    b = Enum.fetch!(circulos, trunc(tamanho / 2))

    {(a + b) / 2, a, b}
  end
end
```

```elixir
CalculoEsculturas.raio_minimo(circulos)
```

```elixir
CalculoEsculturas.raio_maximo(circulos)
```

```elixir
CalculoEsculturas.diametro_minimo(circulos)
```

```elixir
CalculoEsculturas.diametro_maximo(circulos)
```

```elixir
CalculoEsculturas.area_minima(circulos)
```

```elixir
CalculoEsculturas.area_maxima(circulos)
```

```elixir
CalculoEsculturas.media_raios(circulos)
```

```elixir
CalculoEsculturas.numero_de_circulos(circulos)
```

```elixir
CalculoEsculturas.ordena_raios(circulos)
```

```elixir
CalculoEsculturas.ordena_raios_descendente(circulos)
```

```elixir
CalculoEsculturas.variacao_raios(circulos)
```

```elixir
CalculoEsculturas.mediana_raios(circulos)
```

```elixir
{_, circulos} = List.pop_at(circulos, 0)

CalculoEsculturas.mediana_raios(circulos)
```
